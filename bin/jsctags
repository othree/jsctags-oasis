#!/usr/bin/env node

const program = require('commander');
const path = require('path');
const glob = require('glob');
const collect = require('collect-stream');
const flatten = require('lodash.flatten');
const sortBy = require('lodash.sortby');
const async = require('async');
const fs = require('fs');

const jsctags = require('../');

const collection = (val, memo) => {
  memo.push(val);
  return memo;
};

program
  .version('0.0.1')
  .usage('[options] <file ...>')
  .option('-f <tagfile>', 'Use the name specified by tagfile for the tag file. Default is "tags"', 'tags')
  .option('-n, --excmd=number', 'Equivalent to --excmd=number.')
  .option('-o <tagfile>', 'Equivalent to -f tagfile.')
  .option('-p <path>', 'Use path as the default directory for each supplied source file')
  .option('-N, --excmd=pattern', 'Equivalent to --excmd=pattern.')
  .option('-R, --recurse=yes', 'Equivalent to --recurse=yes.')
  .option('--exclude <pattern>', 'Add pattern to a list of excluded files and directories.', collection, ['node_modules/**/*'])
  .option('--excmd <cmd>', 'Determines the type of EX command used to locate tags in the source file.', /^(number|pattern)$/i, 'pattern')
  .option('--json', 'Output json format.')
  .option('--map <map>', 'Controls how file names are mapped to JavaScript language.', '.js.jsx')
  .option('--recurse <yes|no>', 'Recurse  into  directories encountered in the list of supplied files.', /^(yes|no)$/i, 'no')
  .option('--sort <yes|no>', 'Indicates whether the tag file should be sorted on the tag name', /^(yes|no)$/i, 'yes')
  .parse(process.argv);

if (program['excmd=number']) {
  program.excmd = 'number';
} else if (program['excmd=pattern']) {
  program.excmd = 'pattern';
}

if (program.O && program.F === 'tags' && program.rawArgs.indexOf('-f') === -1) {
  program.F = program.O;
}

if (program['recurse=yes']) {
  program.recurse = 'yes';
}

if (program.recurse === 'yes' && !program.args.length) {
  program.args.push('.');
}

if (!program.args.length) {
  console.log('jsctags: No files specified. Try "jsctags --help".');
  process.exit(1);
}

const outputStream = program.F === '-' ? process.stdout : fs.createWriteStream(program.F);

const dir = (function () {
  if (program.P) {
    return path.dirname(path.resolve(program.P));
  }

  return process.cwd();
})();

const extGlob = program.map.replace(/^\./, '').replace(/\./g, ',');

const file = (function () {
  const inputs = program.args;
  const files = program.recurse === 'yes' ?
    inputs.reduce((files, file) => {
      const isdir = fs.lstatSync(file).isDirectory();

      if (isdir) {
        const pattern = path.join(path.relative(process.cwd(), path.resolve(file)), '**/*.{' + extGlob + '}');

        return files.concat(glob.sync(pattern, {
          nosort: true,
          silent: true,
          ignore: program.exclude
        }));
      }

      return files.concat(file);
    }, []) :
    inputs;

  return files.map(file => {
    return path.resolve(process.cwd(), file);
  });
})();

const outputTags = function (tags, options) {
  const normalizedTags = program.sort === 'yes' ? sortBy(flatten(tags), item => item.name) : flatten(tags);
  const ctags = flatten(jsctags.ctags(normalizedTags, options));
  outputStream.write(ctags.join(''));
  outputStream.end();
};

const outputJSON = function (tags) {
  outputStream.write(JSON.stringify(flatten(tags), null, 2));
  outputStream.end();
};

const onResults = function (err, results) {
  if (err) {
    throw err;
  }

  const fn = program.json ? outputJSON : outputTags;

  const tags = results.filter(res => {
    if (res instanceof Error) {
      console.error(err);
      return false;
    }

    return true;
  });

  tags.tagfile = results.tagfile;

  fn(tags, program);
};

const parse = function (ctx, fn) {
  jsctags(ctx, (err, tags) => {
    if (err) {
      return fn(err);
    }

    tags.tagfile = ctx.file;
    tags.forEach(tag => {
      tag.tagfile = ctx.file;
    });

    fn(err, tags);
  });
};

const fromStdin = function () {
  collect(process.stdin, (err, content) => {
    if (err) {
      throw err;
    }

    if (Buffer.isBuffer(content)) {
      content = content.toString();
    }

    parse(
      {
        file,
        dir,
        content
      },
      onResults
    );
  });
};

const fromFiles = function () {
  const files = Array.isArray(file) ? file : [file];
  async.map(
    files,
    (file, fn) => {
      fs.readFile(file, 'utf8', (err, content) => {
        if (err) {
          return fn(null, err);
        }

        parse(
          {
            file,
            dir,
            content
          },
          fn
        );
      });
    },
    onResults
  );
};

(!program.args.length && !program.find ? fromStdin : fromFiles)();
